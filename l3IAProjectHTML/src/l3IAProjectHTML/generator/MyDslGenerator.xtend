/*
 * generated by Xtext 2.25.0
 */
package l3IAProjectHTML.generator

import java.io.FileReader
import java.util.Arrays
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import fRUnivCoteAzurL3IAProjectHTML.Program
import fRUnivCoteAzurL3IAProjectHTML.Graph
import fRUnivCoteAzurL3IAProjectHTML.FileLoader
import fRUnivCoteAzurL3IAProjectHTML.Filter
import java.io.BufferedReader
import java.util.ArrayList

class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		/**Le programme */
		var Program prog = resource.allContents.head as Program
		/**Le nom des colonnes que l'on va selectionner */
		var columns = new ArrayList
		/**ArrayList des colonnes ou l'on va faire des filtres sur les valeurs */
		var colCompa = new ArrayList
		/**Les données selectionnees pour l'affichage du graph */
		val selectData = new ArrayList
		/**Les données du graph */
		var graphique = new ArrayList
		/**Nom de la colonne abs */
		var columnAbs = new ArrayList
		/**Nom des autres colonnes */
		var columnOther = new ArrayList
		/**Nom des autres colonnes sous forme de tableau de string */
		var nameColumnOther = new ArrayList

		
		
		//Traitements des filtres
		for (filter: prog.filter){
			filterToString(filter,columns,colCompa,columnAbs,columnOther)
		}
		//Traitement du graphique
		for (graph:prog.graph){
			graphToString(graph,graphique)
		}
		//Traitement du fichier
		for (file: prog.fileloader){
			fileToString(file,columns,selectData,colCompa)
		}
		
		var x=0
		//Creation du tableau de valeur sous forme de tableau avec des chaines de caracteres
		while (x!= columnOther.size){
			nameColumnOther.add("\'"+columnOther.get(x)+"\'")
			x++
		}
		
	fsa.generateFile('myGeneratedFile.html','''
<!DOCTYPE html>
	<html>
		<head>
			<title>«graphique.get(1)»</title>
		</head>
		<body>
			<div>
				<canvas id="myChart" style="display: block; box-sizing: border-box; height: 376px; width: 752px;" width="940" height="470"></canvas>
			</div>
				<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

				<script>

	 	const CHART_COLORS = {
	  		redt: 'rgba(255, 99, 132, 0.6)',
	  		red: 'rgb(255, 99, 132)',
	  		orange: 'rgb(255, 159, 64)',
	  		yellow: 'rgb(255, 205, 86)',
	  		green: 'rgb(75, 192, 192)',
	 		bluet: 'rgba(54, 162, 235,0.6)',
	  		blue: 'rgb(54, 162, 235)',
	  		purple: 'rgb(153, 102, 255)',
	  		grey: 'rgb(201, 203, 207)'
			};
	
		const NAMED_COLORS = [
	  		CHART_COLORS.red,
	  		CHART_COLORS.orange,
	  		CHART_COLORS.yellow,
	  	    CHART_COLORS.green,
	  		CHART_COLORS.blue,
	  		CHART_COLORS.purple,
	  		CHART_COLORS.grey,
			];
		const data = «selectData»;
		let Datasets =[];
		let otherCols = «nameColumnOther»
		for (let i =0; i <otherCols.length;i++){
			let columnName = otherCols[i];
			let newDataset = {
				label: columnName,
				data: data.map(row => row[columnName]),
				};
			Datasets.push(newDataset);
		}
	  					new Chart(
	    					document.getElementById('myChart'),
	    					{
	      					type: '«graphique.get(0)»',
	      					data: {
	        					labels: data.map(row => row.«columnAbs.get(0)»),
	        					datasets: Datasets
	      					}
	    				}
	  				);
				</script>
		</body>
</html>'''
		
		
	)

	}
	

	/**
	 * Trouver l'index d'une colonne
	 * @param data La liste des données
	 * @param column la colonne ou l'on veut trouver l'index
	 * @return le numero de l'index
	 */
	def int getIndex(List<List<String>> data,String column){
		var index = -1
		for(i : 0..data.get(0).size -1){
			if(data.get(0).get(i).equals(column)){
				index = i
			} 
		}
		return index
	}
	/**
	 * Extraire et selectionner les données en fonction des filtres sur les colonnes ou/et valeurs
	 * @param fileName le nom du fichier
	 * @param columns le nom des colonnes
	 * @param selectedData les données selectionnées
	 * @param colCompa les valeurs des colonnes ou il y a des filtres
	 * @return les données selectionnées
	 */
	def String selectData(String fileName,ArrayList columns,ArrayList selectedData,ArrayList colCompa){
		/**Tableau avec le noms des colonnes */
		var namesCol = new ArrayList
		/**Tableau avec l'index de chaque colonne */
		var indexCol = new ArrayList
		/**Le type de la colonne */
		var typeCol = new ArrayList
		
		//recuperer toutes les données
		/**Tableau des données */
		val data = new ArrayList<List<String>>()
		val reader = new BufferedReader(new FileReader(fileName))
		var line =""
		/**La premiere ligne */
		var firstLine=''
		/**Le nombre de colonne que l'on veut */
		var expetedNumberOfColummns = -1
		var x = 0
		while((line = reader.readLine()) != null){
			//On recupere le nombre de valeur dans la premiere ligne pour pouvoir les recuperer avec les données recuperées
			if (x == 0){
				firstLine=line
				expetedNumberOfColummns=firstLine.split(";").size
				x++
			}
			val values = line.split(";")
			//test pour voir si on a bien le bon nb de colonne de données
			if (values.size == expetedNumberOfColummns){
				data.add(Arrays.asList(values))
			}
		}
		//recuperer les noms des colonnes que l'on veut selectionner
		var i=0
		while (i != columns.size){
			namesCol.add(columns.get(i).toString())
			i++
		}
		i=0
		//recuperer l'index des colonnes selectionnées
		while (i != namesCol.size){
			indexCol.add(getIndex(data,namesCol.get(i)))
			i++
		}
		i=0
		//recuperer le type des colonnes selectionnées
		while (i != indexCol.size){
			typeCol.add(data.get(1).get(indexCol.get(i)))
			i++
		}
		//creation du fichier JSON
		
		/**le json */
		var json="["
		/**Tableau avec le noms des colonnes ou l'on veut creer un filtre */
		var nameColCompa = new ArrayList
		/**Tableau des comparateur utilisées */
		var comparator = new ArrayList
		/**Tableau de la valeur de comparaison */
		var valueCompared = new ArrayList
		i=0
		//Separation de colCompa pour pouvoir extraire le nom des colonnes, le type de comparation et la valeur de cette comparaison
		if(colCompa.isEmpty()==false){
			while (i != colCompa.size){
				val maChaine = colCompa.get(i).toString
				val parties = maChaine.split(" ")
				nameColCompa.add(parties.get(0))
				comparator.add(parties.get(1))
				valueCompared.add(parties.get(2))
				i++
			}
		}
		

		//Ici on commence notre boucle a 2 car il n'est pas necessaire de prendre en compte les deux premieres lignes qui sont le nom et le type de données des colonnes (que l'on a deja
		//recuperé plus tot)
		for (row : 2..data.size-1){
			/**Les données de la ligne */
			var rowData="{"
			/**La valeur du filtre */
			var filter=''
			//On a un element de comparaison
			if(colCompa.isEmpty()==false){
				/**Compteur d'execution */
				var valueCpt=0
				//On recupere le nom de la colonne ou on va appliquer le filtre
				filter = data.get(row).get(getIndex(data,nameColCompa.get(0)))
				if(filter == valueCompared.get(0)){
					for (column :0..namesCol.size-1) {
						//la valeur de la ligne et de la colonne actuelle
						var value = data.get(row).get(indexCol.get(column))
						//Si la valeur n'est pas null
						if (value != null && !value.trim().isEmpty()) {
							//Si la valeur que l'on veut ajouter au JSON est de type String alors on ajoute des "" autour de la valeur
							if (typeCol.get(column).toLowerCase == "string"){
								value = "\"" + value.toString + "\""
							}
							rowData +=  namesCol.get(column) + ":" + value
							//On a plus d'un element dans une ligne JSON	
							if(column != namesCol.size() - 1){
								rowData += ","
							}
							valueCpt++
						}
					}
					//On verifie si on a autant de données dans la ligne qu'on est cencé avoir. Et si c'est notre ligne est bien remplie avec le bon nb de données
					if(!rowData.isEmpty() && valueCpt == namesCol.size){
					rowData += "}"
					selectedData.add(rowData)
					}
					
				}
			}
				//On a pas d'elements de comparaison
				else{
					/**Compteur d'execution */
					var valueCpt=0
					for (column :0..namesCol.size-1) {
						//la valeur de la ligne et de la colonne actuelle
						var value = data.get(row).get(indexCol.get(column))
						//Si la valeur n'est pas null
						if (value != null && !value.trim().isEmpty()) {
						//Si la valeur que l'on veut ajouter au JSON est de type String alors on ajoute des "" autour de la valeur
						if (typeCol.get(column).toLowerCase == "string"){
							value = "\"" + value.toString + "\""
						}
						rowData +=  namesCol.get(column) + ":" + value
						//On a plus d'un element dans une ligne JSON	
						if(column != namesCol.size() - 1){
							rowData += ","
						}
						valueCpt ++
						}
					
					}
					//On verifie si on a autant de données dans la ligne qu'on est cencé avoir et si c'est notre ligne est bien remplie avec le bon nb de données
					if(!rowData.isEmpty() && valueCpt == namesCol.size){
						rowData += "}"
						selectedData.add(rowData)
					}
				}
			}
		json += selectedData.join(",")
		json += "]"
		return selectedData.toString
		}
		/**
		 * Recuperer les valeurs des filtres
		 * @param fi le filtre
		 * @param columns le nom des colonnes
		 * @param columnCompa la valeur du filtre
		 * @param columnAbs la colonne avec l'attribut abs
		 * @param columnOther les colonnes qui ne sont pas abs
		 * @return
		 * le nom des colonnes
		 */
		def filterToString(Filter fi, ArrayList columns,ArrayList columnCompa,ArrayList columnAbs, ArrayList columnOther){
			
			var compa=''
			/**Le comparateur utilisé */
			var comparaison = fi.comparaison
			var abs=fi.abs
			/**La valeur de filtre */
			var elemCompa = fi.elementComparaison
			/**Nom de la colonne ou l'on va filtrer les données */
			var nameCol = fi.columnname
			//On regarde si on a definie une colonne en tant que abcisse
			if (abs != null){
				columnAbs.add(nameCol)
			}
			else if(fi.comparaison.toString == 'none'){
				columnOther.add(nameCol)
			}
			
			
			//Si la comparaison n'est pas egale à none sela signifie que c'est un filtre que l'on va appliquer sur des colonne
			if(fi.comparaison.toString != 'none'){
				if (comparaison.toString=='equal'){
					compa= '='
				}
				else if(comparaison.toString=='inf'){
					compa='<'
				}
				else if(comparaison.toString=='sup'){
					compa='>'
				}
				//on ajoute les elements de comparations au tableau pour pouvoir les utiliser plus tard
				columnCompa.add(nameCol.toString +' '+compa+' '+ elemCompa)
			}
			//C'est une colonne que l'on veut afficher on l'ajoute au colonne
			else{
				columns.add(nameCol)
			}

			
			return columns
			
		}
		/**
		 * Recuperer les données du graph
		 * @param file le fichier
		 * @param columns le nom des colonnes
		 * @param selectData les données selectionnées
		 * @param ColumnsCop valeurs des colonnes ou il y a un filtres
		 * @return
		 * les données du graph
		 */
		def fileToString(FileLoader file, ArrayList columns,ArrayList selectData,ArrayList ColumnsCop){
			var res =""
			/**Le chemin du fichier */
			var path = file.path
				res=selectData(path,columns,selectData,ColumnsCop)
   			return res
		}
		def graphToString(Graph graph, ArrayList graphique) {
			graphique.add(graph.graphtype)
			graphique.add(graph.graphname)
			return graphique
			
	}
	
	}

